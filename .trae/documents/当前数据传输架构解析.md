目前在本项目中，从客户端向服务端传输数据的方式是 **“分离式 SIP” (Unpackaged SIP)**，而不是打包好的 BagIt ZIP 包。

以下是当前实现的详细架构解析：

### 1. 传输层结构：并非 BagIt 包
在 `IngestDemo.tsx` 中，我们使用的是 `multipart/form-data` 格式进行传输。这是一种标准的 HTTP 文件上传方式，包含两个部分：
*   **Part 1 (`file`)**: 原始的二进制数据流（Raw Data）。这是纯数据。
*   **Part 2 (`manifest`)**: 一个 JSON 字符串，包含客户端计算的 `SHA256` 哈希值和提取的元数据。

**代码证据：**
```typescript
// frontend/src/components/IngestDemo.tsx
const formData = new FormData();
formData.append('file', fileData); // 原始文件
formData.append('manifest', JSON.stringify(manifestData)); // 元数据和哈希
```

### 2. 它是 SIP 吗？
**是的，它是一个逻辑上的 SIP (Submission Information Package)。**

虽然它没有被打成一个 `.zip` 包，但它完全符合 OAIS 模型对 SIP 的定义：
*   **内容信息 (Content Information)**: 图片文件本身。
*   **保存描述信息 (PDI)**: Fixity（哈希值）、文件格式、元数据。

这可以被称为 **“分离传输”**。这种方式在处理大文件（如 1GB+ 的 TIFF/RAW）时比在浏览器端打包 BagIt 更高效，原因如下：
*   **性能**：在浏览器中将 1GB 的文件压缩成 ZIP 会消耗大量 CPU 和内存，甚至导致浏览器崩溃。
*   **流式传输**：直接上传原始文件允许浏览器和服务器进行流式处理（Stream），速度更快。

### 3. BagIt 在哪里？
BagIt 结构是在 **服务端** 这一侧体现的：

*   **入库时 (`ingest.py`)**:
    1.  服务器接收文件流和 Manifest。
    2.  服务器一边接收一边计算哈希（Server-side Fixity）。
    3.  比对客户端哈希（Client-side Fixity）。
    4.  **逻辑归档**: 文件存入磁盘，元数据存入数据库。此时，数据库记录 + 物理文件 共同构成了一个“解包状态的 Bag”。

*   **下载时 (`main.py`)**:
    1.  当您点击“下载”时，服务器会**实时动态生成**标准的 BagIt 结构。
    2.  创建 `bagit.txt`, `manifest-sha256.txt`。
    3.  将它们和数据打包成 ZIP 返回给您。

### 总结
*   **传输中**: `Raw Data` + `JSON Manifest` (分离传输，为了性能)。
*   **逻辑上**: 这是一个完整的 `SIP` (包含了数据和校验信息)。
*   **形式上**: 它在传输过程中**不是** BagIt ZIP 包，但在服务端存储和下载时，它实现了 BagIt 的规范和完整性要求。